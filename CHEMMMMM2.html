<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chemical Bonding Simulator - Dynamic Reactions</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        canvas { display: block; }
        
        #video-input {
            position: absolute; top: 0; left: 0;
            width: 640px; height: 480px; 
            z-index: -1; opacity: 0.001;
            transform: scaleX(-1);
        }
        
        #output_canvas {
            position: fixed; top: 10px; right: 10px;
            width: 200px; height: 150px;
            border: 2px solid #00ffff;
            z-index: 1000; opacity: 0.9; 
            background: black; 
            transform: scaleX(-1); 
            object-fit: contain;
            display: none; 
        }
        
        #galaxy-canvas { position: fixed; top: 0; left: 0; z-index: 0; }
        
        #startup-container {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 10; text-align: center;
            background: rgba(0, 0, 0, 0.85);
        }
        
        .curved-button {
            padding: 15px 40px; border: 4px solid white; border-radius: 25px; 
            background: transparent; color: white; font-size: 20px; font-weight: bold;
            cursor: pointer; transition: all 0.2s;
        }
        .curved-button:hover { background: rgba(255, 255, 255, 0.1); box-shadow: 0 0 15px #00ffff; }

        #vfx-container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: none; background: #000; }
        #vfx-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 24px; }
        #instructions { position: absolute; bottom: 20px; width: 100%; text-align: center; color: white; font-size: 16px; z-index: 10; }
    </style>
</head>
<body>

<canvas id="galaxy-canvas"></canvas>

<div id="startup-container">
    <h1 style="font-size: 48px; text-shadow: 0 0 10px #00ffff;">Chemical Bonding Simulator</h1>
    <p>Combine different atoms to see unique reactions!</p>
    <button id="enter-button" class="curved-button">START SIMULATOR</button>
</div>

<div id="vfx-container">
    <div id="vfx-loading">Initializing Sensors...</div>
    <video id="video-input" autoplay playsinline></video>
    <canvas id="output_canvas"></canvas>
    <div id="instructions">
        Pinch to pick up atoms and then merge them to form compounds!
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

<script>
    // --- SETTINGS ---
    const SPHERE_SIZE = 3.5;
    const SCENE_WIDTH = 65; 
    const SCENE_HEIGHT = 45; 
    const REST_Y = -15; 
    const PICKUP_THRESHOLD = 10;
    const BOND_DIST = 13;
    const SMOOTHING = 0.82;

    let renderer, mainCamera, scene, hands;
    let spheresO = [], spheresH = []; 
    let centerSphere, markerO, markerH;
    let wasBonded = false;
    let audioCtx;

    let particles;
    const particleCount = 40;
    const particleVelocities = [];
    let particleMaterial;

    let hL = { x: 0, y: 0, active: false, pinch: 0, heldSphere: null }; 
    let hR = { x: 0, y: 0, active: false, pinch: 0, heldSphere: null }; 

    function playBondSound() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(880, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.1); 
        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    }

    function createParticleSystem() {
        const geo = new THREE.BufferGeometry();
        const posArr = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            particleVelocities.push(new THREE.Vector3());
        }
        geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        particleMaterial = new THREE.PointsMaterial({
            color: 0x8A2BE2,
            size: 0.7,
            transparent: true,
            opacity: 0
        });
        particles = new THREE.Points(geo, particleMaterial);
        scene.add(particles);
    }

    function triggerExplosion(pos, color) {
        particleMaterial.color.set(color);
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = pos.x;
            positions[i * 3 + 1] = pos.y;
            positions[i * 3 + 2] = pos.z;
            particleVelocities[i].set(
                (Math.random() - 0.5) * 1.8,
                (Math.random() - 0.5) * 1.8,
                (Math.random() - 0.5) * 1.8
            );
        }
        particles.geometry.attributes.position.needsUpdate = true;
        particleMaterial.opacity = 1.0;
    }

    function createLabel(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 256;
        ctx.fillStyle = 'white';
        ctx.font = 'Bold 100px Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, 128, 128);
        const tex = new THREE.Texture(canvas);
        tex.needsUpdate = true;
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
            map: tex, 
            transparent: true,
            depthTest: false 
        }));
        sprite.scale.set(7, 7, 1);
        return sprite;
    }

    function createAtom(color, x, labelText) {
        const sphere = new THREE.Mesh(
            new THREE.SphereGeometry(SPHERE_SIZE, 32, 32), 
            new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 })
        );
        sphere.position.set(x, REST_Y, 0);
        sphere.userData.restX = x;
        sphere.userData.restY = REST_Y;
        sphere.userData.symbol = labelText; 
        sphere.add(createLabel(labelText));
        scene.add(sphere);
        return sphere;
    }

    function initVFX() {
        document.getElementById('startup-container').style.display = 'none';
        document.getElementById('vfx-container').style.display = 'block';
        document.getElementById('output_canvas').style.display = 'block';

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('vfx-container').appendChild(renderer.domElement);

        mainCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        mainCamera.position.z = 35;
        scene = new THREE.Scene();

        // --- BLUE GROUP ---
        spheresO.push(createAtom(0x00ffff, 15, 'O2'));
        spheresO.push(createAtom(0x00ffff, 25, 'Cl2'));
        spheresO.push(createAtom(0x00ffff, 5, 'OH')); 
        
        // --- RED GROUP ---
        spheresH.push(createAtom(0xff0000, -5, 'Na')); 
        spheresH.push(createAtom(0xff0000, -15, 'H2'));
        spheresH.push(createAtom(0xff0000, -25, 'Ca')); // Replaced Si with Ca

        centerSphere = new THREE.Mesh(
            new THREE.SphereGeometry(SPHERE_SIZE * 1.6, 32, 32), 
            new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.8 })
        );
        centerSphere.visible = false;
        scene.add(centerSphere);

        createParticleSystem();

        const mGeo = new THREE.SphereGeometry(1.3, 16, 16);
        markerO = new THREE.Mesh(mGeo, new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4 }));
        markerH = new THREE.Mesh(mGeo, new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.4 }));
        scene.add(markerO, markerH);

        hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);
        
        startCamera();
        animate();
    }

    function onResults(results) {
        document.getElementById('vfx-loading').style.display = 'none';
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        hL.active = hR.active = false;
        
        if (results.multiHandLandmarks) {
            results.multiHandLandmarks.forEach((landmarks, i) => {
                const label = results.multiHandedness[i].label; 
                
                // Color Left hand skeleton Red, Right hand skeleton Cyan
                let skeletonColor = (label === 'Right') ? '#ff0000' : '#00ffff';
                
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: skeletonColor, lineWidth: 4});
                drawLandmarks(canvasCtx, landmarks, {color: '#ffffff', lineWidth: 1, radius: 2});
                
                const thumb = landmarks[4];
                const index = landmarks[8];
                const x = (1 - thumb.x) * SCENE_WIDTH - (SCENE_WIDTH / 2);
                const y = (0.5 - thumb.y) * SCENE_HEIGHT;
                const dist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
                const pinch = Math.max(0, Math.min(1, (0.22 - dist) * 12));
                
                if (label === 'Left') {
                    hL.active = true; hL.pinch = pinch;
                    hL.x += (x - hL.x) * SMOOTHING; hL.y += (y - hL.y) * SMOOTHING;
                } else {
                    hR.active = true; hR.pinch = pinch;
                    hR.x += (x - hR.x) * SMOOTHING; hR.y += (y - hR.y) * SMOOTHING;
                }
            });
        }
        canvasCtx.restore();
    }

    function handleHandMovement(hand, atomList, marker) {
        const ease = 0.16;
        const handPos = new THREE.Vector3(hand.x, hand.y, 0);
        if (hand.active && hand.pinch > 0.5) {
            if (!hand.heldSphere) {
                let closest = null;
                let minDist = PICKUP_THRESHOLD;
                [...spheresO, ...spheresH].forEach(atom => {
                    let d = atom.position.distanceTo(handPos);
                    if (d < minDist) { closest = atom; minDist = d; }
                });
                if (closest) hand.heldSphere = closest;
            }
            if (hand.heldSphere) {
                hand.heldSphere.position.x += (hand.x - hand.heldSphere.position.x) * ease;
                hand.heldSphere.position.y += (hand.y - hand.heldSphere.position.y) * ease;
                marker.visible = false;
            } else { marker.position.set(hand.x, hand.y, 0); marker.visible = true; }
        } else { hand.heldSphere = null; marker.visible = false; }
    }

    function animate() {
        requestAnimationFrame(animate);
        const ease = 0.16;
        handleHandMovement(hL, [...spheresO, ...spheresH], markerO);
        handleHandMovement(hR, [...spheresO, ...spheresH], markerH);

        if (particleMaterial.opacity > 0) {
            const pos = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                pos[i*3] += particleVelocities[i].x;
                pos[i*3+1] += particleVelocities[i].y;
                pos[i*3+2] += particleVelocities[i].z;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particleMaterial.opacity -= 0.02; 
        }

        [...spheresO, ...spheresH].forEach(atom => {
            if (atom !== hL.heldSphere && atom !== hR.heldSphere) {
                atom.position.x += (atom.userData.restX - atom.position.x) * ease;
                atom.position.y += (atom.userData.restY - atom.position.y) * ease;
                atom.visible = true;
            }
            atom.children[0].scale.set(7, 7, 1); 
        });

        if (hL.heldSphere && hR.heldSphere) {
            const distance = hL.heldSphere.position.distanceTo(hR.heldSphere.position);
            
            if (distance < BOND_DIST) {
                const s1 = hL.heldSphere.userData.symbol;
                const s2 = hR.heldSphere.userData.symbol;
                let resultText = "??";
                let resultColor = 0xFFFFFF; 

                const check = (a, b) => (s1 === a && s2 === b) || (s1 === b && s2 === a);

                // Updated reactions for Calcium (Ca)
                if (check('Ca', 'O')) { resultText = "CaO"; resultColor = 0xFFFACD; } 
                else if (check('Ca', 'Cl2')) { resultText = "CaCl₂"; resultColor = 0xADFF2F; }
                else if (check('H2', 'Cl2')) { resultText = "HCl"; resultColor = 0x00008B; }
                else if (check('Na', 'Cl2')) { resultText = "NaCl"; resultColor = 0x006400; }
                else if (check('H2', 'O2') || check('H', 'OH')) { resultText = "H₂O"; resultColor = 0x8A2BE2; }
                else if (check('Ca', 'O2')){resultText = "CaO"; resultColor = 0x771083;}
                else if (check('Na', 'O2')) { resultText = "Na₂O"; resultColor = 0xFFA500; }
                else if (check('Na', 'OH')) { resultText = "NaOH"; resultColor = 0xFFC0CB; }
                else if (check('Ca', 'OH')) {resultText = "Ca(OH)2"; resultColor = 0x00FF00;}

                if (!wasBonded && resultText !== "??") {
                    centerSphere.children.forEach(child => centerSphere.remove(child));
                    centerSphere.add(createLabel(resultText));
                    centerSphere.material.color.set(resultColor);
                    playBondSound(); 
                    triggerExplosion(centerSphere.position, resultColor);
                    wasBonded = true; 
                }

                if (resultText !== "??") {
                    centerSphere.visible = true;
                    hL.heldSphere.visible = hR.heldSphere.visible = false;
                    centerSphere.position.lerpVectors(hL.heldSphere.position, hR.heldSphere.position, 0.5);
                }
            } else {
                centerSphere.visible = false;
                hL.heldSphere.visible = hR.heldSphere.visible = true;
                wasBonded = false;
            }
        } else {
            centerSphere.visible = false;
            wasBonded = false;
        }

        renderer.render(scene, mainCamera);
    }

    async function startCamera() {
        const video = document.getElementById('video-input');
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
            const canvas = document.getElementById('output_canvas');
            canvas.width = video.videoWidth; canvas.height = video.videoHeight;
            const sendFrame = async () => { await hands.send({image: video}); requestAnimationFrame(sendFrame); };
            sendFrame();
        };
    }

    const bgRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('galaxy-canvas'), alpha: true });
    bgRenderer.setSize(window.innerWidth, window.innerHeight);
    const bgScene = new THREE.Scene();
    const bgCam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    bgCam.position.z = 10;
    const bgGeo = new THREE.BufferGeometry();
    const bgPos = new Float32Array(3000);
    for (let i = 0; i < 3000; i++) bgPos[i] = (Math.random() - 0.5) * 200;
    bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
    const stars = new THREE.Points(bgGeo, new THREE.PointsMaterial({ size: 0.1, color: 0xffffff }));
    bgScene.add(stars);
    function animBG() { requestAnimationFrame(animBG); stars.rotation.y += 0.0004; bgRenderer.render(bgScene, bgCam); }
    animBG();

    document.getElementById('enter-button').onclick = initVFX;
</script>
</body>
</html>
